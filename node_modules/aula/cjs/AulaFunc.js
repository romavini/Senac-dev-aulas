"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AXR = _interopRequireDefault(require("./AXR"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AulaFunc =
/*#__PURE__*/
function () {
  function AulaFunc(tunnel) {
    _classCallCheck(this, AulaFunc);

    this.tunnel = tunnel;
  }
  /**
  * Create Media
  * Create media
  * @async
  * @param loc
  * @param {string} loc.server_id
  * @param body
  * @param {object} body.media
  * @returns {Promise<{media: object}>}
  */


  _createClass(AulaFunc, [{
    key: "mediaCreate",
    value: function mediaCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["mediaCreate", "/servers/:server_id/media", "POST"], loc, body);
    }
    /**
    * Get Media Key
    * Get media key
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "mediaKey",
    value: function mediaKey() {
      return (0, _AXR.default)(this.tunnel, ["mediaKey", "/servers/:server_id/k/:media_id/:format", "GET"], {});
    }
    /**
    * Get Media Access
    * Check if user has media access
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "mediaAccess",
    value: function mediaAccess() {
      return (0, _AXR.default)(this.tunnel, ["mediaAccess", "/mediaAccess", "GET"], {});
    }
    /**
    * Get Media
    * Get media object. You don't need to use this function to find the video url and you shouldn't use it for that. It is only for service tasks
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {string} body.media_id
    * @returns {Promise<{media: object}>}
    */

  }, {
    key: "mediaGet",
    value: function mediaGet(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["mediaGet", "/servers/:server_id/media/:media_id", "GET"], loc, body);
    }
    /**
    * Upload Media
    * Upload media
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {string} body.media_id
    * @returns {Promise<{media: object}>}
    */

  }, {
    key: "mediaUpload",
    value: function mediaUpload(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["mediaUpload", "/servers/:server_id/media/:media_id/upload", "POST"], loc, body);
    }
    /**
    * Media Analysis
    * Get media analysis
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "mediaAnalysis",
    value: function mediaAnalysis() {
      return (0, _AXR.default)(this.tunnel, ["mediaAnalysis", "/servers/:server_id/media/:media_id/analysis", "GET"], {});
    }
    /**
    * User Status
    * Update the user status
    * @async
    * @param loc
    * @param {string} loc.session_id
    * @param body
    * @param {boolean} body.afk
    * @param {boolean} body.mobile
    * @param {boolean} body.playing
    * @param {string} body.server_id
    * @param {string} body.collection_id
    * @param {string} body.article_id
    * @param {string} body.atext
    * @param {string} body.ctext
    * @param {string} body.lang
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "userStatus",
    value: function userStatus(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["userStatus", "/my/status", "PUT"], loc, body);
    }
    /**
    * Upload User Avatar
    * Upload user avatar
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "userUpload",
    value: function userUpload() {
      return (0, _AXR.default)(this.tunnel, ["userUpload", "/my/upload/:type", "POST"], {});
    }
    /**
    * Delete Media
    * Delete media
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {string} body.media_id
    * @returns {Promise<{media: object}>}
    */

  }, {
    key: "mediaDelete",
    value: function mediaDelete(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["mediaDelete", "/servers/:server_id/media/:media_id", "DELETE"], loc, body);
    }
    /**
    * Create Article
    * Create article
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param body
    * @param {object} body.article
    * @param {integer} body.order
    * @returns {Promise<{article: object}>}
    */

  }, {
    key: "articleCreate",
    value: function articleCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleCreate", "/servers/:server_id/articles", "POST"], loc, body);
    }
    /**
    * Search Articles
    * All Search requests have caching mechanism, don't expect changes to take immediate effect. Search server for articles. :server_id is path parameter, the rest are query parameters. Will fit the requirements of frontend __windowing__
    * @async
    * @param loc
    * @param {string} loc.user_id
    * @param {string} loc.server_id
    * @param {string} loc.owner_user_id
    * @param {string} loc.collection_id
    * @param {string} loc.lang
    * @param {Array} loc.tags
    * @param {string} loc.type
    * @param {string} loc.sort
    * @param {boolean} loc.asc
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, articles: Array}>}
    */

  }, {
    key: "articleSearch",
    value: function articleSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleSearch", "/servers/:server_id/articles/search", "GET"], loc);
    }
    /**
    * Recommend Article Next
    * Get the recommendations after article
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "articleRecommendNext",
    value: function articleRecommendNext() {
      return (0, _AXR.default)(this.tunnel, ["articleRecommendNext", "/servers/:server_id/articles/:article_id/recommend", "GET"], {});
    }
    /**
    * Get Article
    * Get article.  If you want `unlisted` - you place the article in a collection which allows @everyone to have VIEW_ARTICLE, but not VIEW_COLLECTION.
    * @async
    * @param loc
    * @param {string} loc.article_id
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {boolean} loc.overview
    * @param {string} loc.lang_ids
    * @returns {Promise<{article: object}>}
    */

  }, {
    key: "articleGet",
    value: function articleGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleGet", "/servers/:server_id/articles/:article_id/lang/:lang_ids", "GET"], loc);
    }
    /**
    * Patch Article
    * Patch article.
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param body
    * @param {object} body.article
    * @returns {Promise<{article: object, article_patch: object}>}
    */

  }, {
    key: "articlePatch",
    value: function articlePatch(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articlePatch", "/servers/:server_id/articles/:article_id", "PATCH"], loc, body);
    }
    /**
    * Modify Article
    * Modify article.
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param body
    * @param {object} body.article
    * @param {integer} body.order
    * @returns {Promise<{article: object, article_patch: object}>}
    */

  }, {
    key: "articleModify",
    value: function articleModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleModify", "/servers/:server_id/articles/:article_id", "PUT"], loc, body);
    }
    /**
    * Render Article
    * Render article.
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "articleRender",
    value: function articleRender() {
      return (0, _AXR.default)(this.tunnel, ["articleRender", "/servers/:server_id/collections/:collection_id/articles/:article_id/render", "POST"], {});
    }
    /**
    * Delete Article
    * Delete the article in all collections on this server. Delete all its posts. Requires to be owner
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.article_id
    * @returns {Promise<{article: object}>}
    */

  }, {
    key: "articleDelete",
    value: function articleDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleDelete", "/servers/:server_id/articles/:article_id", "DELETE"], loc);
    }
    /**
    * Rate Article
    * Rate article
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param body
    * @param {boolean} body.positive
    * @returns {Promise<{rating: integer}>}
    */

  }, {
    key: "articleRate",
    value: function articleRate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleRate", "/servers/:server_id/articles/:article_id/rate", "POST"], loc, body);
    }
    /**
    * Article Backup
    * Get article backup, which can be imported
    * @async
    * @param loc
    * @param {string} loc.article_id
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @returns {Promise<{article: object}>}
    */

  }, {
    key: "articleBackup",
    value: function articleBackup(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleBackup", "/servers/:server_id/articles/backup", "GET"], loc);
    }
    /**
    * Prune Article
    * Prune article - Remove deleted segments
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @returns {Promise<{article: object, segments: Array}>}
    */

  }, {
    key: "articlePrune",
    value: function articlePrune(loc) {
      return (0, _AXR.default)(this.tunnel, ["articlePrune", "/servers/:server_id/articles/:article_id/prune", "PUT"], loc);
    }
    /**
    * Order Collection Article
    * Change the order of an article inside a collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param body
    * @param {string} body.before_article_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "articleCollectionOrder",
    value: function articleCollectionOrder(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleCollectionOrder", "/servers/:server_id/collections/:collection_id/articles/order/:article_id", "POST"], loc, body);
    }
    /**
    * Autocut Article Segment
    * Autocut Article Segment
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "articleSegmentAutocut",
    value: function articleSegmentAutocut() {
      return (0, _AXR.default)(this.tunnel, ["articleSegmentAutocut", "/servers/:server_id/collections/:collection_id/articles/:article_id/segments/:seg_id/autocut", "POST"], {});
    }
    /**
    * Create Article Segment
    * Create segment
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.seg_id
    * @param body
    * @param {Array} body.segments
    * @returns {Promise<{segments: Array}>}
    */

  }, {
    key: "articleSegmentCreate",
    value: function articleSegmentCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleSegmentCreate", "/servers/:server_id/articles/:article_id/segments/:seg_id", "POST"], loc, body);
    }
    /**
    * Patch Article Segment
    * Patch segment
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.seg_id
    * @param body
    * @param {object} body.segment
    * @returns {Promise<{segment: object}>}
    */

  }, {
    key: "articleSegmentPatch",
    value: function articleSegmentPatch(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleSegmentPatch", "/servers/:server_id/articles/:article_id/segments/:seg_id", "PATCH"], loc, body);
    }
    /**
    * Modify Article Segment
    * Modify segment
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.seg_id
    * @param body
    * @param {object} body.segment
    * @returns {Promise<{segment: object}>}
    */

  }, {
    key: "articleSegmentModify",
    value: function articleSegmentModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["articleSegmentModify", "/servers/:server_id/articles/:article_id/segments/:seg_id", "PUT"], loc, body);
    }
    /**
    * Delete Article Segment
    * Delete segment
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.seg_id
    * @returns {Promise<{segment: object}>}
    */

  }, {
    key: "articleSegmentDelete",
    value: function articleSegmentDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleSegmentDelete", "/servers/:server_id/articles/:article_id/segments/:seg_id", "DELETE"], loc);
    }
    /**
    * Create Post
    * Create post
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param body
    * @param {object} body.post
    * @returns {Promise<{post: object}>}
    */

  }, {
    key: "postCreate",
    value: function postCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["postCreate", "/servers/:server_id/posts", "POST"], loc, body);
    }
    /**
    * Report Post
    * Report post
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "postReport",
    value: function postReport() {
      return (0, _AXR.default)(this.tunnel, ["postReport", "/servers/:server_id/posts/:post_id/report", "POST"], {});
    }
    /**
    * Modify Post
    * Modify post
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param {string} loc.post_id
    * @param body
    * @param {object} body.post
    * @returns {Promise<{post: object}>}
    */

  }, {
    key: "postModify",
    value: function postModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["postModify", "/servers/:server_id/posts/:post_id", "PUT"], loc, body);
    }
    /**
    * Select Correct Answer
    * Select correct answer
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "postSelectAnswer",
    value: function postSelectAnswer() {
      return (0, _AXR.default)(this.tunnel, ["postSelectAnswer", "/servers/:server_id/posts/:post_id/correct", "PUT"], {});
    }
    /**
    * Delete Post
    * Delete post
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param {string} loc.post_id
    * @returns {Promise<{post: object}>}
    */

  }, {
    key: "postDelete",
    value: function postDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["postDelete", "/servers/:server_id/posts/:post_id", "DELETE"], loc);
    }
    /**
    * Rate Post
    * Rate post
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param {string} loc.post_id
    * @param body
    * @param {string} body.vote
    * @returns {Promise<{rating: integer}>}
    */

  }, {
    key: "postRate",
    value: function postRate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["postRate", "/servers/:server_id/posts/:post_id/rate", "POST"], loc, body);
    }
    /**
    * Get Post
    * Get post
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param {string} loc.post_id
    * @param {boolean} loc.overview
    * @param {string} loc.lang
    * @returns {Promise<{post: object}>}
    */

  }, {
    key: "postGet",
    value: function postGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["postGet", "/servers/:server_id/posts/:post_id/lang/:lang_ids", "GET"], loc);
    }
    /**
    * Search Posts
    * Get post subposts
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @param {string} loc.parent_id
    * @param {boolean} loc.overview
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @param {string} loc.sort
    * @param {boolean} loc.asc
    * @param {Array} loc.langs
    * @returns {Promise<{total: integer, posts: Array}>}
    */

  }, {
    key: "postSearch",
    value: function postSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["postSearch", "/servers/:server_id/posts/:post_id/subposts/lang/:lang_ids", "GET"], loc);
    }
    /**
    * Create Server
    * Create new server
    * @async
    * @param body
    * @param {object} body.server
    * @returns {Promise<{server: object}>}
    */

  }, {
    key: "serverCreate",
    value: function serverCreate(body) {
      return (0, _AXR.default)(this.tunnel, ["serverCreate", "/servers", "POST"], {}, body);
    }
    /**
    * Get Server
    * Get server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {boolean} loc.overview
    * @returns {Promise<{server: object}>}
    */

  }, {
    key: "serverGet",
    value: function serverGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverGet", "/servers/:server_id", "GET"], loc);
    }
    /**
    * Add Locale
    * Add locale
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "addLocale",
    value: function addLocale() {
      return (0, _AXR.default)(this.tunnel, ["addLocale", "/locales/add/:lang/:ns", "POST"], {});
    }
    /**
    * Modify Server
    * Modify server info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.server
    * @returns {Promise<{server: object}>}
    */

  }, {
    key: "serverModify",
    value: function serverModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverModify", "/servers/:server_id", "PUT"], loc, body);
    }
    /**
    * Delete Server
    * Delete server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @returns {Promise<{server: object}>}
    */

  }, {
    key: "serverDelete",
    value: function serverDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverDelete", "/servers/:server_id", "DELETE"], loc);
    }
    /**
    * Get Server User Permissions
    * Get user permissions for server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {Array} loc.collection_ids
    * @returns {Promise<{collections: object}>}
    */

  }, {
    key: "serverUserPermissionsGet",
    value: function serverUserPermissionsGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserPermissionsGet", "/servers/:server_id/users/:user_id/permissions", "GET"], loc);
    }
    /**
    * Get Server User
    * Get server user info by user id
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserGet",
    value: function serverUserGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserGet", "/servers/:server_id/users/:user_id", "GET"], loc);
    }
    /**
    * User Notification Put
    * Set notification settings for given resource id and type
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.type
    * @param {string} loc.id
    * @param body
    * @param {object} body.notifications
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverUserNotificationPut",
    value: function serverUserNotificationPut(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverUserNotificationPut", "/servers/:server_id/notifications/:user_id/:type/:id", "PUT"], loc, body);
    }
    /**
    * User Notification List
    * Get all user notifications for given server
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverUserNotificationList",
    value: function serverUserNotificationList() {
      return (0, _AXR.default)(this.tunnel, ["serverUserNotificationList", "/servers/:server_id/notifications", "GET"], {});
    }
    /**
    * User Notification Get
    * Get notification settings for given resource id and type
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.type
    * @param {string} loc.id
    * @returns {Promise<{notifications: object}>}
    */

  }, {
    key: "serverUserNotificationGet",
    value: function serverUserNotificationGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserNotificationGet", "/servers/:server_id/notifications/:user_id/:type/:id", "GET"], loc);
    }
    /**
    * User Notification Token Set
    * Set FCM notification token for user device_id
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "userNotificationTokenSet",
    value: function userNotificationTokenSet() {
      return (0, _AXR.default)(this.tunnel, ["userNotificationTokenSet", "/my/:device_id/token", "PUT"], {});
    }
    /**
    * User Notification Search
    * Search user notifications
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "userNotificationSearch",
    value: function userNotificationSearch() {
      return (0, _AXR.default)(this.tunnel, ["userNotificationSearch", "/my/notifications", "GET"], {});
    }
    /**
    * Send Notification
    * Send notification
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverNotificationSend",
    value: function serverNotificationSend() {
      return (0, _AXR.default)(this.tunnel, ["serverNotificationSend", "/servers/:server_id/notification", "POST"], {});
    }
    /**
    * Mark Server User Resource
    * Put and remove marks on articles and posts such as seen, watched, etc
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.type
    * @param {string} loc.mark
    * @param {string} loc.id
    * @param {boolean} loc.remove
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverUserMark",
    value: function serverUserMark(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserMark", "/servers/:server_id/mark", "POST"], loc);
    }
    /**
    * Clear User Touch
    * Clear missed changes indicator
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverUserTouchClear",
    value: function serverUserTouchClear() {
      return (0, _AXR.default)(this.tunnel, ["serverUserTouchClear", "/servers/:server_id/touch/:type/:id/clear", "PUT"], {});
    }
    /**
    * Leave User Touch
    * Used for showing missed changes indicators. Joins channel for updates
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverUserTouchLeave",
    value: function serverUserTouchLeave() {
      return (0, _AXR.default)(this.tunnel, ["serverUserTouchLeave", "/servers/:server_id/touch/:type/:id/leave", "undefined"], {});
    }
    /**
    * Join User Touch
    * Used for showing missed changes indicators. Joins channel for updates
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverUserTouchJoin",
    value: function serverUserTouchJoin() {
      return (0, _AXR.default)(this.tunnel, ["serverUserTouchJoin", "/servers/:server_id/touch/:type/:id/join", "undefined"], {});
    }
    /**
    * Search Server Users
    * All Search requests have caching mechanism, don't expect changes to take immediate effect.  Search server users. Will fit the requirements of frontend __windowing__
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.role_id
    * @param {string} loc.search
    * @param {string} loc.sort
    * @param {string} loc.display
    * @param {string} loc.collection_id
    * @param {boolean} loc.online
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, users: Array}>}
    */

  }, {
    key: "serverUserSearch",
    value: function serverUserSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserSearch", "/servers/:server_id/users", "GET"], loc);
    }
    /**
    * Search Server User Bans
    * All Search requests have caching mechanism, don't expect changes to take immediate effect. Get banned user by idx in banned list. For the purposes of frontend __windowing__
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, users: Array}>}
    */

  }, {
    key: "serverUserBanSearch",
    value: function serverUserBanSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserBanSearch", "/servers/:server_id/bans", "GET"], loc);
    }
    /**
    * Search Server Invites
    * Search server invites __windowing__
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, invites: Array}>}
    */

  }, {
    key: "serverInviteSearch",
    value: function serverInviteSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverInviteSearch", "/servers/:server_id/invites", "GET"], loc);
    }
    /**
    * Put Server User Ban
    * Ban user
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @returns {Promise<{total_bans: integer, user: object}>}
    */

  }, {
    key: "serverUserBanPut",
    value: function serverUserBanPut(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserBanPut", "/servers/:server_id/bans/:user_id", "PUT"], loc);
    }
    /**
    * Delete Server User Ban
    * Remove user ban
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @returns {Promise<{user: object, total_bans: integer}>}
    */

  }, {
    key: "serverUserBanDelete",
    value: function serverUserBanDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserBanDelete", "/servers/:server_id/bans/:user_id", "DELETE"], loc);
    }
    /**
    * Add Server User
    * User join server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.code
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserAdd",
    value: function serverUserAdd(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserAdd", "/servers/:server_id/users_add", "PUT"], loc);
    }
    /**
    * Add Server User Id
    * User join server without invite code if the server allows it
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.code
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserAddId",
    value: function serverUserAddId(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserAddId", "/servers/:server_id/users_add_id", "PUT"], loc);
    }
    /**
    * Modify Server User
    * Modify server user
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param body
    * @param {object} body.user
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserModify",
    value: function serverUserModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverUserModify", "/servers/:server_id/users/:user_id", "PUT"], loc, body);
    }
    /**
    * Remove Server User
    * User leaves server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserRemove",
    value: function serverUserRemove(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserRemove", "/servers/:server_id/users/:user_id", "DELETE"], loc);
    }
    /**
    * Add Server User Item
    * Add positive or negative amount to user item balance
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.item_id
    * @returns {Promise<{ok: boolean, total: string}>}
    */

  }, {
    key: "serverUserItemAdd",
    value: function serverUserItemAdd(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserItemAdd", "/servers/:server_id/users/:user_id/items/:item_id/add", "POST"], loc);
    }
    /**
    * Add Server User Collection Access
    * add or remove user access to collection  
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.collection_id
    * @param {string} loc.expire_days
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverUserCollectionAccessModify",
    value: function serverUserCollectionAccessModify(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserCollectionAccessModify", "/servers/:server_id/users/:user_id/access/:collection_id", "POST"], loc);
    }
    /**
    * Put Server User Role
    * User is assigned to server role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.role_id
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserRolePut",
    value: function serverUserRolePut(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserRolePut", "/servers/:server_id/users/:user_id/roles/:role_id", "PUT"], loc);
    }
    /**
    * Delete Server User Role
    * User is dismissed from server role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param {string} loc.role_id
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "serverUserRoleDelete",
    value: function serverUserRoleDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserRoleDelete", "/servers/:server_id/users/:user_id/roles/:role_id", "DELETE"], loc);
    }
    /**
    * Create Server Game
    * Create game
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.game
    * @returns {Promise<{game: object}>}
    */

  }, {
    key: "serverGameCreate",
    value: function serverGameCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverGameCreate", "/servers/:server_id/games", "POST"], loc, body);
    }
    /**
    * Modify Server Game
    * Modify game
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.game_id
    * @param body
    * @param {object} body.game
    * @returns {Promise<{game: object}>}
    */

  }, {
    key: "serverGameModify",
    value: function serverGameModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverGameModify", "/servers/:server_id/games/:game_id", "PUT"], loc, body);
    }
    /**
    * Delete Server Game
    * Delete game
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.game_id
    * @returns {Promise<{game: object}>}
    */

  }, {
    key: "serverGameDelete",
    value: function serverGameDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverGameDelete", "/servers/:server_id/games/:game_id", "DELETE"], loc);
    }
    /**
    * Game Score
    * Get game score for target id
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverGameScoreGet",
    value: function serverGameScoreGet() {
      return (0, _AXR.default)(this.tunnel, ["serverGameScoreGet", "/servers/:server_id/game/:game_id/:id/score", "GET"], {});
    }
    /**
    * Get Server Game Stats
    * Get game stats
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverGameStatsGet",
    value: function serverGameStatsGet() {
      return (0, _AXR.default)(this.tunnel, ["serverGameStatsGet", "/servers/:server_id/games/:game_id/stats", "GET"], {});
    }
    /**
    * Get Server Game
    * Get gameinfo
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.game_id
    * @returns {Promise<{game: object}>}
    */

  }, {
    key: "serverGameGet",
    value: function serverGameGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverGameGet", "/servers/:server_id/games/:game_id", "GET"], loc);
    }
    /**
    * Search Server Games
    * All Search requests have caching mechanism, don't expect changes to take immediate effect. Get gameinfo
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, games: Array}>}
    */

  }, {
    key: "serverGameSearch",
    value: function serverGameSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverGameSearch", "/servers/:server_id/games", "GET"], loc);
    }
    /**
    * Create Server Item
    * Create item
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.item
    * @returns {Promise<{item: object}>}
    */

  }, {
    key: "serverItemCreate",
    value: function serverItemCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverItemCreate", "/servers/:server_id/items", "POST"], loc, body);
    }
    /**
    * Modify Server Item
    * Modify item
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.item_id
    * @param body
    * @param {object} body.item
    * @returns {Promise<{item: object}>}
    */

  }, {
    key: "serverItemModify",
    value: function serverItemModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverItemModify", "/servers/:server_id/items/:item_id", "PUT"], loc, body);
    }
    /**
    * Delete Server Item
    * Delete item
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.item_id
    * @param {boolean} loc.force
    * @returns {Promise<{item: object}>}
    */

  }, {
    key: "serverItemDelete",
    value: function serverItemDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverItemDelete", "/servers/:server_id/items/:item_id", "DELETE"], loc);
    }
    /**
    * Get Server Item
    * Get item info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.item_id
    * @returns {Promise<{item: object}>}
    */

  }, {
    key: "serverItemGet",
    value: function serverItemGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverItemGet", "/servers/:server_id/items/:item_id", "GET"], loc);
    }
    /**
    * Search Server Items
    * All Search requests have caching mechanism, don't expect changes to take immediate effect. Get item info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, items: Array}>}
    */

  }, {
    key: "serverItemSearch",
    value: function serverItemSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverItemSearch", "/servers/:server_id/items", "GET"], loc);
    }
    /**
    * Create Server Invite
    * Create invite code for a server
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.invite
    * @returns {Promise<{invite: object}>}
    */

  }, {
    key: "serverInviteCreate",
    value: function serverInviteCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverInviteCreate", "/servers/:server_id/invites", "POST"], loc, body);
    }
    /**
    * Modify Server Invite
    * Modify uses or expires
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.invite_id
    * @param body
    * @param {object} body.invite
    * @returns {Promise<{invite: object}>}
    */

  }, {
    key: "serverInviteModify",
    value: function serverInviteModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverInviteModify", "/servers/:server_id/invites/:invite_id", "PUT"], loc, body);
    }
    /**
    * Delete Server Invite
    * Delete invite for a server
    * @async
    * @param loc
    * @param {string} loc.invite_id
    * @param {string} loc.server_id
    * @returns {Promise<{invite: object}>}
    */

  }, {
    key: "serverInviteDelete",
    value: function serverInviteDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverInviteDelete", "/servers/:server_id/invites/:invite_id", "DELETE"], loc);
    }
    /**
    * Get Server Invite
    * Get invite code info
    * @async
    * @param loc
    * @param {string} loc.code
    * @returns {Promise<{invite: object}>}
    */

  }, {
    key: "serverInviteGet",
    value: function serverInviteGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverInviteGet", "/servers/invites/:code", "GET"], loc);
    }
    /**
    * Create Server Collection
    * Create server collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.collection
    * @returns {Promise<{perm: integer, collection: object}>}
    */

  }, {
    key: "serverCollectionCreate",
    value: function serverCollectionCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionCreate", "/servers/:server_id/collections", "POST"], loc, body);
    }
    /**
    * Create Server Collection Module
    * Create server collection module
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.module
    * @returns {Promise<{module: object}>}
    */

  }, {
    key: "serverModuleCreate",
    value: function serverModuleCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverModuleCreate", "/servers/:server_id/collections/:collection_id/modules", "POST"], loc, body);
    }
    /**
    * Add Server Collection Articles
    * Add articles to a server collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param body
    * @param {Array} body.article_ids
    * @param {integer} body.order
    * @returns {Promise<{ok: boolean, added: integer}>}
    */

  }, {
    key: "serverCollectionArticleAdd",
    value: function serverCollectionArticleAdd(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionArticleAdd", "/servers/:server_id/collections/:collection_id/articles", "POST"], loc, body);
    }
    /**
    * Remove Server Collection Articles
    * Remove articles from a server collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param body
    * @param {Array} body.article_ids
    * @returns {Promise<{ok: boolean, removed: integer}>}
    */

  }, {
    key: "serverCollectionArticleRemove",
    value: function serverCollectionArticleRemove(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionArticleRemove", "/servers/:server_id/collections/:collection_id/articles", "DELETE"], loc, body);
    }
    /**
    * Move Module
    * Reorder modules
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverModuleMove",
    value: function serverModuleMove() {
      return (0, _AXR.default)(this.tunnel, ["serverModuleMove", "/servers/:server_id/collections/:collection_id/modules_move", "PUT"], {});
    }
    /**
    * Move Collection
    * Move between categories and reorder collections
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {Array} body.moves
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverCollectionMove",
    value: function serverCollectionMove(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionMove", "/servers/:server_id/collections_move", "PUT"], loc, body);
    }
    /**
    * Move Role
    * Change role order
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {Array} body.moves
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverRoleMove",
    value: function serverRoleMove(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverRoleMove", "/servers/:server_id/roles_move", "PUT"], loc, body);
    }
    /**
    * Move Category
    * Reorder categories
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {Array} body.moves
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverCategoryMove",
    value: function serverCategoryMove(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCategoryMove", "/servers/:server_id/categories_move", "PUT"], loc, body);
    }
    /**
    * Modify Server Collection Module
    * Modify server collection module
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.module_id
    * @param body
    * @param {object} body.module
    * @returns {Promise<{modue: object}>}
    */

  }, {
    key: "serverModuleModify",
    value: function serverModuleModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverModuleModify", "/servers/:server_id/collections/:collection_id/modules/:module_id", "PUT"], loc, body);
    }
    /**
    * Modify Server Collection
    * Modify server collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param body
    * @param {object} body.collection
    * @returns {Promise<{collection: object}>}
    */

  }, {
    key: "serverCollectionModify",
    value: function serverCollectionModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionModify", "/servers/:server_id/collections/:collection_id", "PUT"], loc, body);
    }
    /**
    * Modify Server Category
    * Modify server category
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.category_id
    * @param body
    * @param {object} body.category
    * @returns {Promise<{category: object}>}
    */

  }, {
    key: "serverCategoryModify",
    value: function serverCategoryModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCategoryModify", "/servers/:server_id/categories/:collection_id", "PUT"], loc, body);
    }
    /**
    * Buy Collection
    * Buy collection
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverCollectionBuy",
    value: function serverCollectionBuy() {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionBuy", "/servers/:server_id/collections/:collection_id/buy", "POST"], {});
    }
    /**
    * Get Collection
    * Get server collection info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {boolean} loc.overview
    * @returns {Promise<{collection: object}>}
    */

  }, {
    key: "serverCollectionGet",
    value: function serverCollectionGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionGet", "/servers/:server_id/collections/:collection_id", "GET"], loc);
    }
    /**
    * Get Collection Module
    * Get server collection module info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @returns {Promise<{module: object}>}
    */

  }, {
    key: "serverModuleGet",
    value: function serverModuleGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverModuleGet", "/servers/:server_id/collections/:collection_id/modules/:module_id", "GET"], loc);
    }
    /**
    * Create Server Category
    * Create server category
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.category
    * @returns {Promise<{category: object}>}
    */

  }, {
    key: "serverCategoryCreate",
    value: function serverCategoryCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverCategoryCreate", "/servers/:server_id/categories", "POST"], loc, body);
    }
    /**
    * Get Category
    * Get server category info
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.category_id
    * @returns {Promise<{category: object}>}
    */

  }, {
    key: "serverCategoryGet",
    value: function serverCategoryGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverCategoryGet", "/servers/:server_id/categories/:category_id", "GET"], loc);
    }
    /**
    * Delete Server Category
    * Delete server category
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.category_id
    * @returns {Promise<{category: object}>}
    */

  }, {
    key: "serverCategoryDelete",
    value: function serverCategoryDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverCategoryDelete", "/servers/:server_id/categories/:collection_id", "DELETE"], loc);
    }
    /**
    * Delete Server Collection
    * Delete server collection
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @returns {Promise<{collection: object}>}
    */

  }, {
    key: "serverCollectionDelete",
    value: function serverCollectionDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverCollectionDelete", "/servers/:server_id/collections/:collection_id", "DELETE"], loc);
    }
    /**
    * Delete Server Collection Module
    * Delete server collection module
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.module_id
    * @returns {Promise<{module: object}>}
    */

  }, {
    key: "serverModuleDelete",
    value: function serverModuleDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverModuleDelete", "/servers/:server_id/collections/:collection_id/modules/:module_id", "DELETE"], loc);
    }
    /**
    * Get Server User Collections
    * Get server collections visible to user
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @returns {Promise<{collections: object, categories: object, perm: integer, srvuser: object}>}
    */

  }, {
    key: "serverUserDetailsGet",
    value: function serverUserDetailsGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverUserDetailsGet", "/servers/:server_id/user/:user_id/collections", "GET"], loc);
    }
    /**
    * Create Server Role
    * Create server role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param body
    * @param {object} body.role
    * @returns {Promise<{role: object}>}
    */

  }, {
    key: "serverRoleCreate",
    value: function serverRoleCreate(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverRoleCreate", "/servers/:server_id/roles", "POST"], loc, body);
    }
    /**
    * Get Server Role
    * Get serfer role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.role_id
    * @returns {Promise<{role: object}>}
    */

  }, {
    key: "serverRoleGet",
    value: function serverRoleGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverRoleGet", "/servers/:server_id/roles/:role_id", "GET"], loc);
    }
    /**
    * Modify Server Role
    * Modify server role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.role_id
    * @param body
    * @param {object} body.role
    * @returns {Promise<{role: object}>}
    */

  }, {
    key: "serverRoleModify",
    value: function serverRoleModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["serverRoleModify", "/servers/:server_id/roles/:role_id", "PUT"], loc, body);
    }
    /**
    * Delete Server Role
    * Delete server role
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.role_id
    * @returns {Promise<{role: object}>}
    */

  }, {
    key: "serverRoleDelete",
    value: function serverRoleDelete(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverRoleDelete", "/servers/:server_id/roles/:role_id", "DELETE"], loc);
    }
    /**
    * Search Server Tags
    * Search server tags. Used in autocompleting search
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {Array} loc.tags
    * @param {string} loc.search
    * @returns {Promise<{tags: Array}>}
    */

  }, {
    key: "serverTagsSearch",
    value: function serverTagsSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverTagsSearch", "/servers/:server_id/tags/:tags/:search", "GET"], loc);
    }
    /**
    * Register User
    * Register new user
    * @async
    * @param body
    * @param {object} body.user
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userRegister",
    value: function userRegister(body) {
      return (0, _AXR.default)(this.tunnel, ["userRegister", "/users/register", "POST"], {}, body);
    }
    /**
    * Logout User
    * Logout user. If you logout anonymous user, you will get another anonymous user. Logged out = anonymous
    * @async
    * @param body
    * @param {string} body.user_id
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "userLogout",
    value: function userLogout(body) {
      return (0, _AXR.default)(this.tunnel, ["userLogout", "/users/logout", "POST"], {}, body);
    }
    /**
    * Get User Servers
    * Get user servers
    * @async
    * @param loc
    * @param {string} loc.user_id
    * @returns {Promise<{servers: object}>}
    */

  }, {
    key: "userServersGet",
    value: function userServersGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["userServersGet", "/users/:user_id/servers", "GET"], loc);
    }
    /**
    * Authenticate Anonymous User
    * Authenticate anonymous users
    * @async
    * @param body
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userAuthenticateAnonymous",
    value: function userAuthenticateAnonymous(body) {
      return (0, _AXR.default)(this.tunnel, ["userAuthenticateAnonymous", "/users/authenticate/anonymous", "POST"], {}, body);
    }
    /**
    * Authenticate User Token
    * Authenticate by providing token
    * @async
    * @param body
    * @param {string} body.token
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userAuthenticate",
    value: function userAuthenticate(body) {
      return (0, _AXR.default)(this.tunnel, ["userAuthenticate", "/users/authenticate/token", "POST"], {}, body);
    }
    /**
    * Authenticate User Password
    * Authenticate user with password
    * @async
    * @param body
    * @param {string} body.email
    * @param {string} body.password
    * @param {object} body.social
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userAuthenticatePassword",
    value: function userAuthenticatePassword(body) {
      return (0, _AXR.default)(this.tunnel, ["userAuthenticatePassword", "/users/authenticate/password", "POST"], {}, body);
    }
    /**
    * Authenticate User Social
    * Register or Login new user with social network credentials
    * @async
    * @param body
    * @param {object} body.social
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userAuthenticateSocial",
    value: function userAuthenticateSocial(body) {
      return (0, _AXR.default)(this.tunnel, ["userAuthenticateSocial", "/users/authenticate/social", "POST"], {}, body);
    }
    /**
    * Modify User Preferences
    * Save user preferences
    * @async
    * @param loc
    * @param {string} loc.user_id
    * @param body
    * @param {object} body.preferences
    * @returns {Promise<{preferences: object}>}
    */

  }, {
    key: "userPreferencesModify",
    value: function userPreferencesModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["userPreferencesModify", "/users/:user_id/preferences", "PUT"], loc, body);
    }
    /**
    * Get User Preferences
    * Leave user preferences
    * @async
    * @param loc
    * @param {string} loc.user_id
    * @returns {Promise<{preferences: object}>}
    */

  }, {
    key: "userPreferencesGet",
    value: function userPreferencesGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["userPreferencesGet", "/users/:user_id/preferences", "GET"], loc);
    }
    /**
    * Modify User
    * Change your own user properties
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.user_id
    * @param body
    * @param {object} body.user
    * @returns {Promise<{user: object}>}
    */

  }, {
    key: "userModify",
    value: function userModify(loc, body) {
      return (0, _AXR.default)(this.tunnel, ["userModify", "/users/:user_id", "PUT"], loc, body);
    }
    /**
    * Get User
    * Get map of users. `PUBLIC`
    * @async
    * @param loc
    * @param {Array} loc.user_ids
    * @returns {Promise<{users: object}>}
    */

  }, {
    key: "userGet",
    value: function userGet(loc) {
      return (0, _AXR.default)(this.tunnel, ["userGet", "/users", "GET"], loc);
    }
    /**
    * Search Server Admin Log
    * All Search requests have caching mechanism, don't expect changes to take immediate effect. Search the administrative events logs
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {integer} loc.from
    * @param {integer} loc.to
    * @returns {Promise<{total: integer, events: Array}>}
    */

  }, {
    key: "serverAdminLogSearch",
    value: function serverAdminLogSearch(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverAdminLogSearch", "/servers/:server_id/alog", "GET"], loc);
    }
    /**
    * Introduce User Email
    * Introduce user email and find out if they are already registred. `PUBLIC`
    * @async
    * @param body
    * @param {string} body.email
    * @returns {Promise<{registered: boolean, user: object}>}
    */

  }, {
    key: "userIntroduction",
    value: function userIntroduction(body) {
      return (0, _AXR.default)(this.tunnel, ["userIntroduction", "/users/introduction", "POST"], {}, body);
    }
    /**
    * Claim Lost Pass
    * Claim lost password and the server will attempt to send email with code
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "userClaimLostPass",
    value: function userClaimLostPass() {
      return (0, _AXR.default)(this.tunnel, ["userClaimLostPass", "/users/claim_lost_pass", "POST"], {});
    }
    /**
    * Verify User Lost Pass Code
    * Check if lost password code is valid
    * @async
    * @param body
    * @param {string} body.email
    * @param {string} body.code
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "userVerifyLostPassCode",
    value: function userVerifyLostPassCode(body) {
      return (0, _AXR.default)(this.tunnel, ["userVerifyLostPassCode", "/users/verify_lost_pass_code", "POST"], {}, body);
    }
    /**
    * Change User Lost Pass
    * Change user lost password
    * @async
    * @param body
    * @param {string} body.email
    * @param {string} body.code
    * @param {string} body.password
    * @returns {Promise<{user: object, version: integer}>}
    */

  }, {
    key: "userChangeLostPass",
    value: function userChangeLostPass(body) {
      return (0, _AXR.default)(this.tunnel, ["userChangeLostPass", "/users/lost_pass_new_pass", "POST"], {}, body);
    }
    /**
    * Get Changelog
    * Get changelog for a user
    * @async
    * @param body
    * @returns {Promise<{changelog: Array}>}
    */

  }, {
    key: "userChangelogGet",
    value: function userChangelogGet(body) {
      return (0, _AXR.default)(this.tunnel, ["userChangelogGet", "/users/:user_id/changelog", "GET"], {}, body);
    }
    /**
    * Join Server Channel
    * Join server update channel
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverChannelJoin",
    value: function serverChannelJoin(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverChannelJoin", "undefined", "undefined"], loc);
    }
    /**
    * Leave Server Channel
    * Leave server update channel
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "serverChannelLeave",
    value: function serverChannelLeave(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverChannelLeave", "undefined", "undefined"], loc);
    }
    /**
    * Join User Channel
    * Join user update channel
    * @async
    * @param loc
    * @param {Array} loc.ids
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "userChannelJoin",
    value: function userChannelJoin(loc) {
      return (0, _AXR.default)(this.tunnel, ["userChannelJoin", "undefined", "undefined"], loc);
    }
    /**
    * Leave User Channel
    * Leave user update channel
    * @async
    * @param loc
    * @param {string} loc.user_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "userChannelLeave",
    value: function userChannelLeave(loc) {
      return (0, _AXR.default)(this.tunnel, ["userChannelLeave", "undefined", "undefined"], loc);
    }
    /**
    * Join Post Thread Channel
    * Join thread update channel
    * @async
    * @param loc
    * @param {string} loc.parent_id
    * @param {string} loc.post_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "postChannelJoin",
    value: function postChannelJoin(loc) {
      return (0, _AXR.default)(this.tunnel, ["postChannelJoin", "undefined", "undefined"], loc);
    }
    /**
    * Leave Post Thread Channel
    * Leave thread update channel
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.parent_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "postChannelLeave",
    value: function postChannelLeave(loc) {
      return (0, _AXR.default)(this.tunnel, ["postChannelLeave", "undefined", "undefined"], loc);
    }
    /**
    * Join Article Channel
    * Join article updates channel
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.article_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "articleChannelJoin",
    value: function articleChannelJoin(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleChannelJoin", "undefined", "undefined"], loc);
    }
    /**
    * Leave Article Channel
    * Leave article updates channel
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.article_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "articleChannelLeave",
    value: function articleChannelLeave(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleChannelLeave", "undefined", "undefined"], loc);
    }
    /**
    * Join Collection Channel
    * Join collection updates 
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "collectionChannelJoin",
    value: function collectionChannelJoin(loc) {
      return (0, _AXR.default)(this.tunnel, ["collectionChannelJoin", "undefined", "undefined"], loc);
    }
    /**
    * Leave Collection Channel
    * Leave collection updates
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.article_id
    * @returns {Promise<{ok: boolean}>}
    */

  }, {
    key: "collectionChannelLeave",
    value: function collectionChannelLeave(loc) {
      return (0, _AXR.default)(this.tunnel, ["collectionChannelLeave", "undefined", "undefined"], loc);
    }
    /**
    * Rebuild Article
    * Rebuild article in database. Fixes the article if app development changed the database
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @param {string} loc.collection_id
    * @param {string} loc.article_id
    * @returns {Promise<{article: object}>}
    */

  }, {
    key: "articleRebuild",
    value: function articleRebuild(loc) {
      return (0, _AXR.default)(this.tunnel, ["articleRebuild", "/servers/:server_id/articles/:article_id/rebuild", "PUT"], loc);
    }
    /**
    * Dump Server
    * Dump server  database
    * @async
    * @param loc
    * @param {string} loc.server_id
    * @returns {Promise<{server: object}>}
    */

  }, {
    key: "serverDump",
    value: function serverDump(loc) {
      return (0, _AXR.default)(this.tunnel, ["serverDump", "/servers/:server_id/dump", "GET"], loc);
    }
    /**
    * Wipe Everything
    * Restart the database from scratch
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "wipeEverything",
    value: function wipeEverything() {
      return (0, _AXR.default)(this.tunnel, ["wipeEverything", "undefined", "undefined"], {});
    }
    /**
    * Clean Server Tags
    * Clean server tags
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverTagsCleanup",
    value: function serverTagsCleanup() {
      return (0, _AXR.default)(this.tunnel, ["serverTagsCleanup", "undefined", "undefined"], {});
    }
    /**
    * Soft Restart
    * Restart server
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "serverSoftRestart",
    value: function serverSoftRestart() {
      return (0, _AXR.default)(this.tunnel, ["serverSoftRestart", "undefined", "undefined"], {});
    }
    /**
    * Wipe Demo Data
    * Remove demo servers and users which are created with tests
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "demoWipe",
    value: function demoWipe() {
      return (0, _AXR.default)(this.tunnel, ["demoWipe", "undefined", "undefined"], {});
    }
    /**
    * Cluster Info
    * Get info from all nodes
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "clusterInfo",
    value: function clusterInfo() {
      return (0, _AXR.default)(this.tunnel, ["clusterInfo", "undefined", "undefined"], {});
    }
    /**
    * Cleanup Deleted
    * Cleanup deleted servers in case they failed to fully delete
    * @async
    * @returns {Promise<{}>}
    */

  }, {
    key: "cleanupDeleted",
    value: function cleanupDeleted() {
      return (0, _AXR.default)(this.tunnel, ["cleanupDeleted", "undefined", "undefined"], {});
    }
  }]);

  return AulaFunc;
}();

var _default = AulaFunc;
exports.default = _default;