import AulaFunc from "./AulaFunc";
import io from "socket.io-client";

/**
 * Aula
 *
 * @param {object} user
 * @param {boolean} tunnel_overwrite
 *
 * @returns {AulaFunc}
 */

const Aula = ({
  user,
  host = process.env.API_HOST ? process.env.API_HOST : "localhost",
  socket = true,
  tunnel_overwrite,
  ref_FormData = FormData,
  demo = true,
  ref_fetch = fetch
} = {}) => {
  const tunnel = tunnel_overwrite ? tunnel_overwrite : {};

  const a = new AulaFunc(tunnel);
  a.host = host;
  a.is_socket = socket;
  if (socket) {
    // setup socket
    a.connect = () => {
      return new Promise(resolve => {
        if (!tunnel.socket)
          tunnel.socket = io.connect("https://" + a.host, {
            "reconnection delay": 0,
            "reopen delay": 0,
            "force new connecion": true,
            transports: ["websocket"],
            //secure: true,

            rejectUnauthorized: false
          });
        tunnel.send = (func, data) => {
          if (demo) data.demo = true;
          return new Promise(resolve =>
            tunnel.socket.emit(func[0], data, resolve)
          );
        };

        tunnel.socket.on("connect", async () => {
          if (user) {
            let resp;
            if (user.token) {
              resp = await a.userAuthenticate(user);
            } else {
              resp = await a.userAuthenticatePassword(user);
            }
            tunnel.user = { ...user, id: resp.user.id };
            a.id = resp.user.id;

            resolve(tunnel.socket);
          } else {
            let resp = await a.userAuthenticateAnonymous({});
            tunnel.user = { id: resp.user.id };
            a.id = resp.user.id;

            resolve(tunnel.socket);
          }
        });
        tunnel.socket.on("connect_error", err => {});
        tunnel.socket.on("connect_timeout", err => {});
        tunnel.socket.on("error", err => {});
      });
    };
    a.disconnect = () => {
      tunnel.socket.disconnect();
    };
  } else {
    //setup rest
    a.connect = async () => {
      if (user) {
        if (user.token) {
          let resp = await a.userAuthenticate(user);
        } else {
          let resp = await a.userAuthenticatePassword(user);
        }
      } else {
        let resp = await a.userAuthenticateAnonymous({});
      }
      //tunnel.user = resp.user;
    };
    a.disconnect = () => {};
    const loc_esc = data => {
      if (Array.isArray(data)) return data.join(",");
      return data;
    };

    tunnel.send = (func, data) => {
      let extra = {
        headers: {},
        method: func[2]
      };
      if (demo) data.demo = true;

      let target_host = a.host;
      if (data.host) target_host = data.host; // host in the data can overwrite default host for fetch requests
      delete data.host;

      let token = tunnel.user ? tunnel.user.token : user ? user.token : false;
      if (token) extra.headers.Authorization = "Bearer " + token;

      if (data.body && ["POST", "PUT", "PATCH"].indexOf(extra.method) !== -1) {
        if (data.body instanceof ref_FormData) {
          extra.body = data.body;
          //extra.headers["Content-Type"] = "multipart/form-data";
          if (data.body.getHeaders)
            extra.headers = { ...extra.headers, ...data.body.getHeaders() }; // getHeaders is not standart according to npm package
        } else {
          extra.body = JSON.stringify(data.body);
          extra.headers["Content-Type"] = "application/json";
        }
      }

      let locParam = func[1];
      let queryParam = [];
      Object.keys(data).forEach(paramKey => {
        if (paramKey === "body") return;
        if (locParam.indexOf(":" + paramKey) !== -1) {
          locParam = locParam.replace(":" + paramKey, data[paramKey]);
        } else {
          queryParam.push(paramKey + "=" + escape(loc_esc(data[paramKey])));
        }
      });

      locParam = locParam.replace(/\:[^\/]+/g, "false");

      if (queryParam.length) locParam += "?" + queryParam.join("&");

      let url = "https://" + target_host + "/api" + locParam;
      //  console.warn("FETCH", url, extra);
      return ref_fetch(url, extra)
        .then(function(response) {
          return response.json();
        })
        .then(resp => {
          if (
            func[0] === "userAuthenticateAnonymous" ||
            func[0] === "userRegister" ||
            func[0] === "userLogout" ||
            func[0] === "userAuthenticate" ||
            func[0] === "userAuthenticatePassword" ||
            func[0] === "userAuthenticateSocial" ||
            func[0] === "userChangeLostPass"
          ) {
            if (resp && resp.body && resp.body.user) {
              tunnel.user = resp.body.user;
              a.id = tunnel.user.id;
            }
          }
          return resp;
        })
        .catch(err => {
          console.warn(err);
          throw new Error(
            "Bad fetch on " + url + "\n\n" + JSON.stringify(extra)
          );
        });
    };
  }

  return a;
};

export default Aula;
